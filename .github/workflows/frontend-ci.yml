name: Frontend CI/CD Pipeline

on:
  push:
    branches: [main, develop]
    paths:
      - "frontend/**"
      - ".github/workflows/frontend-ci.yml"
  pull_request:
    branches: [main]
    paths:
      - "frontend/**"
      - ".github/workflows/frontend-ci.yml"

jobs:
  # STAGE 1: TEST
  test:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./frontend
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"
          cache-dependency-path: "./frontend/package-lock.json"

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm run test:run -- --reporter=verbose
        env:
          CI: true

  # STAGE 2: BUILD
  build:
    runs-on: ubuntu-latest
    needs: test
    defaults:
      run:
        working-directory: ./frontend
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"
          cache-dependency-path: "./frontend/package-lock.json"

      - name: Install dependencies
        run: npm ci

      - name: Build project
        run: npm run build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build
          path: frontend/dist/

  # STAGE 3: DEPLOY TO STAGING
  deploy-staging:
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/develop'
    steps:
      # - name: Checkout code
        # uses: actions/checkout@v4 

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: frontend-build
          path: dist

      - name: Install Netlify CLI
        run: npm install -g netlify-cli

      - name: Deploy to Netlify (Staging)
        run: |
          netlify deploy --dir=dist --message="Staging Deploy - ${{ github.sha }}" --alias=staging
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID_STAGING }}

  # STAGE 4: DEPLOY TO PRODUCTION
  # deploy:
  #   runs-on: ubuntu-latest
  #   needs: build
  #   if: github.ref == 'refs/heads/main'
  #   steps:
  #     # - name: Checkout code
  #       # uses: actions/checkout@v4

  #     - name: Download build artifacts
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: frontend-build
  #         path: dist

  #     - name: Install Netlify CLI
  #       run: npm install -g netlify-cli

  #     - name: Deploy to Netlify (Production)
  #       run: |
  #         netlify deploy --prod --dir=dist --message="Production Deploy - ${{ github.sha }}"
  #       env:
  #         NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
  #         NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID_PROD }}


  # STAGE 4: DEPLOY TO PRODUCTION WITH SMOKE TEST AND ROLLBACK
  deploy:
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main'
    env:
      NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
      NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID_PROD }}
      SMOKE_PATH: "/"                       # path to check
      EXPECTED_TEXT: "<!DOCTYPE"            # small marker present on healthy page
      ROLLBACK_LIMIT: 10
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: frontend-build
          path: dist

      - name: Debug build artifacts
        run: |
          echo "Contents of dist directory:"
          ls -laR dist/ || echo "dist directory not found!"
          echo ""
          echo "Checking for index.html:"
          if [ -f "dist/index.html" ]; then
            echo "index.html found"
            echo "First 50 lines:"
            head -n 50 dist/index.html
          else
            echo "index.html NOT found in dist/"
            echo "Available files:"
            find dist/ -type f
          fi

      - name: Install Netlify CLI & jq
        run: |
          npm install -g netlify-cli
          sudo apt-get update && sudo apt-get install -y jq curl

      - name: Deploy to Netlify (Production) (JSON)
        id: netlify_deploy
        run: |
          # do a production deploy and print JSON
          netlify deploy --prod --dir=dist --message="Production Deploy - $GITHUB_SHA" --json > deploy.json || (cat deploy.json && exit 1)
          cat deploy.json
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}

      - name: Extract deploy data and URL
        id: extract
        run: |
          # Get the URL from Netlify CLI response (uses 'url' not 'ssl_url')
          DEPLOY_URL=$(jq -r '.url' deploy.json)
          
          if [ -z "$DEPLOY_URL" ] || [ "$DEPLOY_URL" = "null" ]; then
            echo "Could not extract deploy URL from Netlify response"
            cat deploy.json
            exit 1
          fi
          
          echo "deploy_url=$DEPLOY_URL" >> $GITHUB_OUTPUT
          echo "Successfully extracted URL: $DEPLOY_URL"

      
      
      - name: Smoke test deployed site
        id: smoke
        run: |
          URL=${{ steps.extract.outputs.deploy_url }}
          echo "üîç Testing deployment at: $URL"
          
          # Wait a few seconds for Netlify to propagate
          echo "Waiting 10 seconds for Netlify to propagate..."
          sleep 10
          
          # Try for up to 60s
          for i in {1..12}; do
            echo ""
            echo "üì° Attempt $i/12..."
            
            # Get status code
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$URL" || echo "000")
            echo "HTTP Status: $STATUS"
            
            if [ "$STATUS" = "200" ]; then
              # Get full response
              RESPONSE=$(curl -s "$URL")
              
              # Show content type
              CONTENT_TYPE=$(curl -s -I "$URL" | grep -i "content-type:" | tr -d '\r')
              echo "Content-Type: $CONTENT_TYPE"
              
              # Show first 200 chars
              echo "Response preview (first 200 chars):"
              echo "$RESPONSE" | head -c 200
              echo ""
              
              # Check if it's HTML
              if echo "$RESPONSE" | grep -qi "<!DOCTYPE\|<html"; then
                echo "‚úÖ Valid HTML detected"
                
                # STRICT CHECK: Must have root div with proper id
                if echo "$RESPONSE" | grep -q '<div id="root"'; then
                  echo "‚úÖ Found root div with id='root'"
                  echo "‚úÖ SMOKE TEST PASSED"
                  echo "SMOKE_OK=true" >> $GITHUB_OUTPUT
                  exit 0
                fi
                
                # Alternative: check for app div
                if echo "$RESPONSE" | grep -q '<div id="app"'; then
                  echo "‚úÖ Found app div with id='app'"
                  echo "‚úÖ SMOKE TEST PASSED"
                  echo "SMOKE_OK=true" >> $GITHUB_OUTPUT
                  exit 0
                fi
                
                # FAIL if root/app div not found
                echo "‚ùå Missing required root div with id='root' or id='app'"
                echo "Found in HTML:"
                echo "$RESPONSE" | grep -oP '<div[^>]*id="[^"]*"[^>]*>' | head -5
              else
                echo "‚ùå Response is not HTML"
                echo "Full response:"
                echo "$RESPONSE"
              fi
            else
              echo "‚ùå Received HTTP $STATUS (expected 200)"
            fi
            
            if [ $i -lt 12 ]; then
              echo "Retrying in 5 seconds..."
              sleep 5
            fi
          done
          
          echo ""
          echo "‚ùå SMOKE TEST FAILED after 60 seconds"
          echo "SMOKE_OK=false" >> $GITHUB_OUTPUT
          exit 1
        continue-on-error: true

      - name: Rollback if smoke failed
        if: steps.smoke.outcome != 'success'
        run: |
          echo "Smoke test failed; attempting rollback"
          SITE=${{ env.NETLIFY_SITE_ID }}
          TOKEN=${{ env.NETLIFY_AUTH_TOKEN }}
          # list last ready deploys
          DEPLOYS_JSON=$(curl -s -H "Authorization: Bearer $TOKEN" "https://api.netlify.com/api/v1/sites/$SITE/deploys?limit=${{ env.ROLLBACK_LIMIT }}")
          # find first ready deploy that is not the latest (index 1)
          PREV_ID=$(echo "$DEPLOYS_JSON" | jq -r '[.[] | select(.state=="ready")] | .[1].id')
          if [ -z "$PREV_ID" ] || [ "$PREV_ID" = "null" ]; then
            echo "No previous ready deploy found to restore"
            exit 1
          fi
          echo "Restoring deploy $PREV_ID"
          curl -s -X POST -H "Authorization: Bearer $TOKEN" "https://api.netlify.com/api/v1/sites/$SITE/deploys/$PREV_ID/restore" -o /tmp/restore.json -w "\nHTTP_STATUS:%{http_code}\n"
          cat /tmp/restore.json
          # optionally notify via Slack
          if [ -n "${{ secrets.SLACK_WEBHOOK }}" ]; then
            curl -s -X POST -H 'Content-type: application/json' --data "{\"text\":\"Rollback executed for ${GITHUB_REPOSITORY} on ${GITHUB_REF} ‚Äî restored deploy ${PREV_ID}\"}" ${{ secrets.SLACK_WEBHOOK }}
          fi

