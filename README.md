# Group Portfolio Platform

## Overview

The Group Portfolio Platform is a multi-user web application for showcasing projects, publishing blog posts, and managing member profiles. It provides role-based access for group members and administrators, while allowing public visitors to browse content without authentication.

---

## Software Requirements

### 1. Introduction

#### 1.1 Purpose

- Enable registered users to present projects and publish blogs.
- Admins can manage users and moderate content.
- Public visitors can browse projects, blogs, and member profiles.

#### 1.2 Scope

- User management with authentication and roles.
- Member profiles (skills, bios, links).
- Project showcase (details, tech stack, images).
- Blog publishing (tutorials, insights, updates).
- Admin dashboard for moderation/statistics.
- Public pages for browsing.
- Responsive design (mobile/desktop).
- Security for authentication and file handling.

#### 1.3 Users and Roles

- **Registered User:** Manage own profile, projects, blogs.
- **Admin:** Manage users, moderate content, view stats.
- **Public Visitor:** Browse public content only.

---

### 2. Functional Requirements

#### 2.1 User Management

- Register, login (JWT), password recovery/reset.
- Secure password storage.
- Role-based access (Admin/User).

#### 2.2 User Profiles

- Create/update personal profile.
- View other members’ profiles.

#### 2.3 Project Management

- Create/edit/delete own projects.
- Projects include title, description, tech stack, screenshots, links.
- Projects shown on profile and public showcase.

#### 2.4 Blog Management

- Write/edit/publish/delete own blog posts.
- Blog posts include title, content, cover image, tags.
- Public access to blog listing and posts.

#### 2.5 Admin Dashboard

- Manage users (add/edit/deactivate).
- Moderate/remove projects/blogs.
- View statistics.

#### 2.6 Public Pages

- Homepage highlights.
- Browse members/projects/blogs.

#### 2.7 File & Media Management

- Upload profile photos, project images, blog covers.
- Secure file storage and linking.

#### 2.8 Search & Navigation

- Search for members, projects, blogs.
- Filter/sort by category, tag, skill.

---

# CI/CD Pipeline Documentation

## Table of Contents
1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Backend Pipeline](#backend-pipeline)
4. [Frontend Pipeline](#frontend-pipeline)
5. [Tools & Technologies](#tools--technologies)
6. [Configuration Files](#configuration-files)
7. [Testing Strategy](#testing-strategy)
8. [Deployment Process](#deployment-process)
9. [Challenges & Solutions](#challenges--solutions)
10. [Monitoring & Rollback](#monitoring--rollback)

---

## Overview

This project uses **GitHub Actions** for CI/CD automation with separate pipelines for backend and frontend. The workflows support multi-environment deployments (staging and production) with automated testing, code quality checks, and rollback capabilities.

### Key Features
- ✅ Automated testing on every push/PR
- ✅ Code quality enforcement (linting, formatting, type checking)
- ✅ Multi-stage deployments (staging → production)
- ✅ Smoke testing with automatic rollback
- ✅ Dependency caching for faster builds
- ✅ Security scanning with Bandit
- ✅ Coverage reporting to Codecov

---

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                     GitHub Repository                        │
│  (Push to main/develop triggers workflows)                  │
└────────────────┬────────────────────────────────────────────┘
                 │
        ┌────────┴────────┐
        │                 │
        ▼                 ▼
┌───────────────┐  ┌──────────────┐
│   Backend     │  │   Frontend   │
│   Pipeline    │  │   Pipeline   │
└───────┬───────┘  └──────┬───────┘
        │                 │
        ▼                 ▼
   [Build & Test]    [Build & Test]
        │                 │
        ▼                 ▼
   [Code Quality]    [Smoke Test]
        │                 │
        ▼                 ▼
   [Deploy Render]   [Deploy Netlify]
        │                 │
        └────────┬────────┘
                 │
                 ▼
          [Production Ready]
```

---

## Backend Pipeline

**File:** `.github/workflows/backend-ci.yml`

### Stages

#### 1. Build & Setup
```yaml
Jobs: build
Trigger: Push to main/develop or PR to main (backend/** paths)
Python: 3.11
```

**Steps:**
1. **Checkout code** - Clone repository
2. **Set up Python** - Install Python 3.11
3. **Cache dependencies** - Cache pip packages using `~/.cache/pip`
4. **Install dependencies** - Install from `backend/requirements.txt` plus dev tools (black, isort, flake8, mypy, bandit, coverage)
5. **Create .env file** - Generate test environment with:
   ```bash
   DEBUG=True
   SECRET_KEY=<auto-generated>
   ALLOWED_HOSTS=localhost,127.0.0.1
   CORS_ALLOWED_ORIGINS=http://localhost:3000,http://127.0.0.1:3000
   DATABASE_URL=sqlite:///:memory:
   ```
6. **Run migrations** - Apply database schema
7. **Django system check** - Validate Django configuration
8. **Collect static files** - Dry-run static collection (non-blocking)

#### 2. Code Quality Checks
```yaml
Jobs: code-quality
Depends on: build
```

**Quality Tools:**
- **Black** - Code formatting enforcement (PEP 8 compliant)
  ```bash
  black --check --diff .
  ```
- **isort** - Import statement sorting
  ```bash
  isort --check-only --diff .
  ```
- **Flake8** - Linting for style violations
  ```bash
  flake8 .
  ```
- **mypy** - Static type checking (continues on error)
  ```bash
  mypy . --ignore-missing-imports
  ```
- **Bandit** - Security vulnerability scanning
  ```bash
  bandit -r . -f json -o bandit-report.json \
    -x "*/tests/*,*/migrations/*,*/venv/*,*/env/*"
  ```

**Configuration:**
- Settings: `backend/pyproject.toml`
- Excludes: tests, migrations, virtual environments

#### 3. Tests & Coverage
```yaml
Jobs: tests
Depends on: build
```

**Steps:**
1. Setup Python & install dependencies
2. Create test `.env` file
3. Setup test database (SQLite in-memory)
4. **Run tests with coverage:**
   ```bash
   coverage run --source='.' manage.py test
   coverage xml    # For Codecov
   coverage html   # For local viewing
   coverage report # Terminal output
   ```
5. **Upload to Codecov** - Send coverage reports for tracking

**Test Configuration:**
- Test runner: Django's built-in test runner
- Database: SQLite in-memory (fast, isolated)
- Coverage source: All backend code (excluding venv, migrations)
- Pytest config: `backend/pytest.ini` (uses `--reuse-db` for speed)

#### 4. Deploy to Staging
```yaml
Jobs: deploy_staging
Depends on: [tests, code-quality]
Trigger: Push to 'develop' branch
```

**Process:**
1. Checkout code
2. Trigger Render deploy webhook:
   ```bash
   curl -X POST ${{ secrets.RENDER_DEPLOY_URL }}
   ```
3. Wait 60 seconds for deployment to complete

**Environment:** Staging (separate from production)

#### 5. Deploy to Production
```yaml
Jobs: deploy-production
Depends on: [tests, code-quality]
Trigger: Push to 'main' branch
```

**Process:**
1. Checkout code
2. Trigger Render production deploy webhook:
   ```bash
   curl -X POST ${{ secrets.RENDER_DEPLOY_PRO_URL }}
   ```
3. Wait 60 seconds for deployment

**Environment:** Production

---

## Frontend Pipeline

**File:** `.github/workflows/frontend-ci.yml`

### Stages

#### 1. Test
```yaml
Jobs: test
Trigger: Push to main/develop or PR to main (frontend/** paths)
Node: 18.x
```

**Steps:**
1. **Checkout code**
2. **Setup Node.js** - Install Node 18 with npm cache
3. **Install dependencies** - `npm ci` (clean install from lockfile)
4. **Run tests** - Execute Vitest test suite
   ```bash
   npm run test:run -- --reporter=verbose
   ```

**Test Framework:** Vitest (configured in `frontend/vite.config.ts`)

#### 2. Build
```yaml
Jobs: build
Depends on: test
```

**Steps:**
1. Checkout code
2. Setup Node.js with cache
3. Install dependencies (`npm ci`)
4. **Build production bundle:**
   ```bash
   npm run build
   ```
5. **Upload artifacts** - Store `frontend/dist/` for deployment

**Build Tool:** Vite (outputs to `dist/`)

#### 3. Deploy to Staging
```yaml
Jobs: deploy-staging
Depends on: build
Trigger: Push to 'develop' branch
Platform: Netlify
```

**Process:**
1. Download build artifacts (`dist/`)
2. Install Netlify CLI globally
3. Deploy to staging alias:
   ```bash
   netlify deploy --dir=dist \
     --message="Staging Deploy - ${{ github.sha }}" \
     --alias=staging
   ```

**Environment Variables:**
- `NETLIFY_AUTH_TOKEN` - Authentication token (secret)
- `NETLIFY_SITE_ID_STAGING` - Staging site ID (secret)

#### 4. Deploy to Production (with Smoke Test & Rollback)
```yaml
Jobs: deploy
Depends on: build
Trigger: Push to 'main' branch
Platform: Netlify
```

**Environment Variables:**
```yaml
NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID_PROD }}
SMOKE_PATH: "/"
EXPECTED_TEXT: "<!DOCTYPE"
ROLLBACK_LIMIT: 10
```

**Process:**

**Step 1: Download & Verify Artifacts**
```bash
# Download build from previous stage
uses: actions/download-artifact@v4

# Debug: Check dist/ contents
ls -laR dist/
head -n 50 dist/index.html
```

**Step 2: Install Tools**
```bash
npm install -g netlify-cli
sudo apt-get install -y jq curl
```

**Step 3: Deploy to Production**
```bash
netlify deploy --prod --dir=dist \
  --message="Production Deploy - $GITHUB_SHA" --json > deploy.json
```

**Step 4: Extract Deploy URL**
```bash
DEPLOY_URL=$(jq -r '.url' deploy.json)
echo "deploy_url=$DEPLOY_URL" >> $GITHUB_OUTPUT
```

**Step 5: Smoke Test** (12 attempts, 5s intervals = 60s total)

**Health Checks:**
1. **HTTP Status** - Must return 200
2. **Content Type** - Must be HTML
3. **DOCTYPE Check** - Must contain `<!DOCTYPE` or `<html>`
4. **Root Element** - Must have `<div id="root">` or `<div id="app">`

**Smoke Test Logic:**
```bash
for i in {1..12}; do
  STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$URL")
  
  if [ "$STATUS" = "200" ]; then
    RESPONSE=$(curl -s "$URL")
    
    # Check for HTML with root div
    if echo "$RESPONSE" | grep -q '<div id="root"'; then
      echo "SMOKE TEST PASSED"
      exit 0
    fi
  fi
  
  sleep 5
done

echo "SMOKE TEST FAILED"
exit 1
```

**Step 6: Automatic Rollback** (if smoke test fails)

**Rollback Process:**
1. Fetch last 10 deploys via Netlify API
2. Find the previous "ready" deploy (index 1)
3. Restore that deploy using Netlify API:
   ```bash
   curl -X POST \
     -H "Authorization: Bearer $TOKEN" \
     "https://api.netlify.com/api/v1/sites/$SITE/deploys/$PREV_ID/restore"
   ```
4. *Optional:* Send Slack notification (if webhook configured)

**Rollback Example:**
```bash
DEPLOYS_JSON=$(curl -s -H "Authorization: Bearer $TOKEN" \
  "https://api.netlify.com/api/v1/sites/$SITE/deploys?limit=10")

PREV_ID=$(echo "$DEPLOYS_JSON" | \
  jq -r '[.[] | select(.state=="ready")] | .[1].id')

curl -X POST -H "Authorization: Bearer $TOKEN" \
  "https://api.netlify.com/api/v1/sites/$SITE/deploys/$PREV_ID/restore"
```

---

## Tools & Technologies

### CI/CD Platform
- **GitHub Actions** - Workflow automation
  - Event-driven triggers (push, pull_request)
  - Matrix builds (multiple Python versions)
  - Job dependencies and conditional execution
  - Secrets management for API keys

### Backend Tools
| Tool | Purpose | Configuration |
|------|---------|---------------|
| **Python 3.11** | Runtime environment | `.python-version`, `pyproject.toml` |
| **pip** | Package management | `requirements.txt` |
| **Django** | Web framework | `backend/manage.py`, `settings.py` |
| **pytest** | Testing framework | `backend/pytest.ini` |
| **coverage** | Code coverage | Integrated with pytest |
| **black** | Code formatter | `pyproject.toml` (line-length: 100) |
| **isort** | Import sorter | `pyproject.toml` (profile: black) |
| **flake8** | Linter | `pyproject.toml` (max-line-length: 100) |
| **mypy** | Type checker | `pyproject.toml` |
| **bandit** | Security scanner | CLI flags (excludes tests/migrations) |
| **Codecov** | Coverage reporting | GitHub Action integration |
| **Render** | Deployment platform | Deploy webhooks (secrets) |

### Frontend Tools
| Tool | Purpose | Configuration |
|------|---------|---------------|
| **Node.js 18** | Runtime environment | `.nvmrc`, `package.json` |
| **npm** | Package management | `package-lock.json` |
| **Vite** | Build tool | `vite.config.ts` |
| **React 18** | UI framework | `package.json` |
| **TypeScript** | Type safety | `tsconfig.json` |
| **Vitest** | Testing framework | `vite.config.ts` (test section) |
| **ESLint** | Linter | `.eslintrc.cjs` |
| **Prettier** | Code formatter | `.prettierrc` |
| **Netlify CLI** | Deployment tool | Installed in workflow |
| **Netlify** | Hosting platform | API tokens (secrets) |
| **jq** | JSON parser | Used for deploy URL extraction |
| **curl** | HTTP client | Used for smoke tests & API calls |

### Caching Strategy
- **Backend:** `~/.cache/pip` - Cached by `requirements.txt` hash
- **Frontend:** npm cache - Cached by `package-lock.json` hash
- **Benefits:** 30-50% faster build times on cache hit

---

## Configuration Files

### Backend Configuration

**`backend/pyproject.toml`** - Tool settings
```toml
[tool.black]
line-length = 100
target-version = ['py311']
exclude = '''
/(
    \.eggs
  | \.git
  | \.venv
  | env
  | migrations
)/
'''

[tool.isort]
profile = "black"
line_length = 100
skip_gitignore = true
known_django = "django"
sections = ["FUTURE", "STDLIB", "DJANGO", "THIRDPARTY", "FIRSTPARTY", "LOCALFOLDER"]

[tool.mypy]
python_version = "3.11"
ignore_missing_imports = true
exclude = [
    "migrations/",
    "tests/",
    "env/",
]
```

**`backend/pytest.ini`** - Test configuration
```ini
[pytest]
DJANGO_SETTINGS_MODULE = project.settings
python_files = tests.py test_*.py *_tests.py
addopts = --reuse-db --no-migrations
```

**`backend/.env.example`** - Environment template
```bash
DEBUG=True
SECRET_KEY=your-secret-key-here
ALLOWED_HOSTS=localhost,127.0.0.1
CORS_ALLOWED_ORIGINS=http://localhost:3000,http://127.0.0.1:3000
DATABASE_URL=sqlite:///db.sqlite3
SENTRY_DSN=your-sentry-dsn
```

### Frontend Configuration

**`frontend/vite.config.ts`** - Build & test config
```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/test/setup.ts',
  },
  build: {
    outDir: 'dist',
    sourcemap: true,
  },
})
```

**`frontend/package.json`** - Scripts
```json
{
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "test": "vitest",
    "test:run": "vitest run",
    "test:ci": "vitest run --reporter=verbose",
    "lint": "eslint . --ext ts,tsx",
    "format": "prettier --write \"src/**/*.{ts,tsx,css}\""
  }
}
```

**`frontend/.env.example`** - Environment template
```bash
VITE_API_URL=http://localhost:8000/api
VITE_SENTRY_DSN=your-sentry-dsn
```

### GitHub Secrets Required

**Backend (Render):**
- `RENDER_DEPLOY_URL` - Staging deploy webhook
- `RENDER_DEPLOY_PRO_URL` - Production deploy webhook

**Frontend (Netlify):**
- `NETLIFY_AUTH_TOKEN` - Netlify personal access token
- `NETLIFY_SITE_ID_STAGING` - Staging site ID
- `NETLIFY_SITE_ID_PROD` - Production site ID

**Optional:**
- `CODECOV_TOKEN` - Codecov upload token (public repos don't need this)
- `SLACK_WEBHOOK` - Slack notifications for rollbacks

---

## Testing Strategy

### Backend Testing

**Framework:** Django TestCase + pytest

**Test Structure:**
```
backend/
├── blog/
│   ├── tests.py           # Project & Post API tests
│   └── test_*.py          # Additional test modules
├── users/
│   ├── tests.py           # User & Auth API tests
│   └── test_*.py
└── pytest.ini             # Pytest configuration
```

**Test Categories:**

1. **API Endpoint Tests** (`blog/tests.py`)
   - CRUD operations for Projects and Posts
   - Permission checks (ADMIN, MEMBER, VIEWER roles)
   - Custom actions (my_projects, featured, toggle_publish)
   - File upload handling (images)

2. **Authentication Tests** (`users/tests.py`)
   - Registration with validation
   - Login with JWT token generation
   - Token refresh
   - Password reset flow
   - Profile updates

3. **Permission Tests**
   - Role-based access control
   - Owner-only modifications
   - Public vs authenticated endpoints

**Test Patterns:**

```python
from rest_framework.test import APITestCase
from rest_framework_simplejwt.tokens import RefreshToken
from django.urls import reverse

class ProjectAPITestCase(APITestCase):
    def setUp(self):
        # Create test user
        self.user = User.objects.create_user(
            email="test@example.com",
            password="testpass123",
            role="MEMBER"
        )
        
        # Get JWT token
        token = RefreshToken.for_user(self.user)
        self.client.credentials(
            HTTP_AUTHORIZATION=f'Bearer {token.access_token}'
        )
    
    def test_create_project(self):
        url = reverse('blog:project-list')  # Uses APPEND_SLASH=False
        data = {
            'title': 'Test Project',
            'description': 'Test description',
            'tech_stack': 'Python,Django,React'
        }
        response = self.client.post(url, data, format='json')
        self.assertEqual(response.status_code, 201)
        self.assertEqual(response.data['owner'], self.user.id)
```

**Coverage Requirements:**
- Minimum: 80% (enforced in CI)
- Current: Check Codecov badge
- Excluded: migrations, venv, third-party code

### Frontend Testing

**Framework:** Vitest + React Testing Library

**Test Structure:**
```
frontend/
├── src/
│   ├── components/
│   │   └── tested/
│   │       ├── Header.test.tsx
│   │       └── LoginModal.test.tsx
│   ├── contexts/
│   │   └── __tests__/
│   │       └── AuthContext.test.tsx
│   └── test/
│       └── setup.ts          # Test environment setup
└── vite.config.ts            # Vitest configuration
```

**Test Categories:**

1. **Component Tests**
   - Rendering behavior
   - User interactions (clicks, form submissions)
   - Conditional rendering based on props/state
   - Integration with context providers

2. **Context Tests**
   - AuthContext login/logout flow
   - State management
   - LocalStorage persistence

3. **Integration Tests**
   - Full user flows (login → create project → logout)
   - API integration (mocked with MSW if needed)

**Test Patterns:**

```typescript
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { BrowserRouter } from 'react-router-dom';
import { AuthProvider } from '@/contexts/AuthContext';
import LoginModal from '@/components/LoginModal';

describe('LoginModal Component', () => {
  it('submits login form with credentials', async () => {
    render(
      <BrowserRouter>
        <AuthProvider>
          <LoginModal isOpen={true} onClose={vi.fn()} />
        </AuthProvider>
      </BrowserRouter>
    );

    // Fill form
    fireEvent.change(screen.getByLabelText(/email/i), {
      target: { value: 'test@example.com' }
    });
    fireEvent.change(screen.getByLabelText(/password/i), {
      target: { value: 'password123' }
    });

    // Submit
    fireEvent.click(screen.getByRole('button', { name: /sign in/i }));

    // Assert
    await waitFor(() => {
      expect(screen.queryByText(/error/i)).not.toBeInTheDocument();
    });
  });
});
```

**Test Utilities:**
- `@testing-library/react` - Component testing
- `@testing-library/user-event` - User interaction simulation
- `vi.fn()` - Vitest mocks
- `happy-dom` - Fast DOM implementation for tests

---

## Deployment Process

### Backend Deployment (Render)

**Platform:** [Render](https://render.com)

**Deployment Type:** Web Service

**Configuration:** `render.yaml` (if exists) or dashboard config

**Process:**
1. **Trigger:** Push to `main` or `develop` branch
2. **Webhook:** GitHub Actions calls Render deploy hook
3. **Render Actions:**
   - Pulls latest code from GitHub
   - Installs dependencies from `requirements.txt`
   - Runs `python manage.py migrate`
   - Runs `python manage.py collectstatic --noinput`
   - Starts Gunicorn server: `gunicorn project.wsgi:application`
4. **Health Check:** Render pings `/health` endpoint (if configured)
5. **Live:** New deployment becomes active

**Environment Variables (Render Dashboard):**
```bash
DEBUG=False
SECRET_KEY=<production-secret>
ALLOWED_HOSTS=yourapp.onrender.com
DATABASE_URL=postgresql://...  # Auto-provided by Render
CORS_ALLOWED_ORIGINS=https://grouportfolio.netlify.app
SENTRY_DSN=<your-sentry-dsn>
```

**Database:** PostgreSQL (managed by Render)

**Static Files:** Served via WhiteNoise or S3 (check `settings.py`)

**Logs:** View in Render dashboard → Logs tab

### Frontend Deployment (Netlify)

**Platform:** [Netlify](https://www.netlify.com)

**Deployment Type:** Static Site

**Process:**

**Staging Deployment:**
1. **Trigger:** Push to `develop` branch
2. **Build:** GitHub Actions runs `npm run build`
3. **Upload:** Netlify CLI uploads `dist/` folder
4. **Deploy:** `netlify deploy --alias=staging`
5. **URL:** `https://staging--grouportfolio.netlify.app`

**Production Deployment:**
1. **Trigger:** Push to `main` branch
2. **Build:** GitHub Actions runs `npm run build`
3. **Upload:** Netlify CLI uploads `dist/` folder
4. **Deploy:** `netlify deploy --prod`
5. **Smoke Test:** 12 attempts over 60 seconds
   - Check HTTP 200 response
   - Verify HTML content with `<div id="root">`
   - If fails → automatic rollback to previous deploy
6. **URL:** `https://grouportfolio.netlify.app`

**Build Settings (Netlify Dashboard):**
```bash
Build command: npm run build
Publish directory: dist
Node version: 18
```

**Environment Variables (Netlify Dashboard):**
```bash
VITE_API_URL=https://your-backend.onrender.com/api
VITE_SENTRY_DSN=<your-sentry-dsn>
```

**Redirects:** `frontend/public/_redirects`
```
/*    /index.html   200
```
(Enables client-side routing)

**Headers:** `frontend/public/_headers` (optional)
```
/*
  X-Frame-Options: DENY
  X-Content-Type-Options: nosniff
  Referrer-Policy: strict-origin-when-cross-origin
```

---

## Challenges & Solutions

### Challenge 1: Mixed Content Errors (HTTPS → HTTP)

**Problem:**
- Netlify frontend (HTTPS) couldn't call local backend (HTTP)
- Browser blocked requests due to mixed content policy
- Error: "The page was loaded over HTTPS, but requested an insecure resource"

**Solution:**
1. **Development:** Run frontend locally (not via Netlify) during dev
2. **Production:** Deploy backend to Render with HTTPS support
3. **Environment Variables:** Use `VITE_API_URL` to switch between local/production APIs
   ```typescript
   const API_BASE_URL = import.meta.env.VITE_API_URL || "http://127.0.0.1:8080/api";
   ```

### Challenge 2: HSTS Browser Caching

**Problem:**
- Browser cached HTTPS preference for `localhost`
- Kept upgrading HTTP requests to HTTPS automatically
- Persisted across browser restarts

**Solution:**
1. **Clear HSTS:** `chrome://net-internals/#hsts` → Delete domain
2. **Use IP Address:** `127.0.0.1` instead of `localhost`
3. **Different Port:** Use port 8080 (never seen HTTPS traffic)
4. **Incognito Mode:** Test in private browsing

### Challenge 3: TensorFlow/ML Dependencies

**Problem:**
- `requirements.txt` included TensorFlow, PyTorch, scikit-learn
- Caused installation failures in CI (Python version conflicts)
- Unnecessary for a Django REST + portfolio app

**Solution:**
- **Removed:** All ML libraries (TensorFlow, PyTorch, NumPy, Pandas, OpenCV)
- **Kept:** Only Django, DRF, PostgreSQL, and dev tools
- **Result:** Faster installs, no version conflicts

### Challenge 4: Test Failures - Router Context

**Problem:**
- `LoginModal.test.tsx` failed with "useNavigate() may be used only in the context of a <Router> component"
- Component used `useNavigate()` but tests didn't provide Router

**Solution:**
```typescript
import { BrowserRouter } from 'react-router-dom';

render(
  <BrowserRouter>
    <AuthProvider>
      <LoginModal isOpen={true} onClose={vi.fn()} />
    </AuthProvider>
  </BrowserRouter>
);
```

### Challenge 5: SQLite File Lock During Git Checkout

**Problem:**
- Git couldn't switch branches while Django dev server was running
- Error: "Unlink of file 'backend/db.sqlite3' failed"
- Database file was locked by SQLite

**Solution:**
1. **Stop Django server** before git operations
2. **Add to `.gitignore`:**
   ```bash
   backend/db.sqlite3
   backend/db.sqlite3-journal
   ```
3. **Use PostgreSQL in production** (no file locks)

### Challenge 6: Smoke Test False Positives

**Problem:**
- Initial smoke test only checked HTTP 200
- Netlify returned 200 for error pages (404, 500)
- Bad deploys passed smoke test

**Solution:**
**Enhanced smoke test** with multiple checks:
```bash
# 1. HTTP status must be 200
STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$URL")

# 2. Response must be HTML
if echo "$RESPONSE" | grep -qi "<!DOCTYPE\|<html"; then

# 3. Must contain root div
if echo "$RESPONSE" | grep -q '<div id="root"'; then
  echo "SMOKE TEST PASSED"
fi
```

### Challenge 7: Deploy Artifact Path Issues

**Problem:**
- Netlify CLI couldn't find `dist/` directory
- Build artifacts uploaded to wrong location
- Deploy failed with "Error: No index.html found"

**Solution:**
1. **Debug step** to inspect artifact contents:
   ```bash
   ls -laR dist/
   head -n 50 dist/index.html
   ```
2. **Correct artifact path** in download step:
   ```yaml
   - uses: actions/download-artifact@v4
     with:
       name: frontend-build
       path: dist  # Explicitly set path
   ```

### Challenge 8: Rollback API Authentication

**Problem:**
- Netlify API required authentication for rollback
- Token management in GitHub Actions

**Solution:**
```bash
TOKEN=${{ secrets.NETLIFY_AUTH_TOKEN }}
curl -H "Authorization: Bearer $TOKEN" \
  "https://api.netlify.com/api/v1/sites/$SITE/deploys"
```

### Challenge 9: Dependency Caching

**Problem:**
- Slow CI builds (5-10 minutes)
- Re-downloading same dependencies every run

**Solution:**
**Backend pip cache:**
```yaml
- uses: actions/cache@v3
  with:
    path: ~/.cache/pip
    key: ${{ runner.os }}-pip-${{ hashFiles('backend/requirements.txt') }}
```

**Frontend npm cache:**
```yaml
- uses: actions/setup-node@v4
  with:
    cache: 'npm'
    cache-dependency-path: './frontend/package-lock.json'
```

**Result:** 30-50% faster builds

### Challenge 10: Secret Management

**Problem:**
- Multiple API keys needed (Render, Netlify, Codecov)
- Security risk if committed to repo

**Solution:**
- **GitHub Secrets** for all sensitive values
- **Environment-specific secrets** (staging vs production)
- **Example pattern:**
  ```yaml
  env:
    NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
    NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID_PROD }}
  ```

---

## Monitoring & Rollback

### Monitoring Tools

**1. GitHub Actions Dashboard**
- View workflow runs: Repository → Actions tab
- See logs for each job/step
- Re-run failed workflows

**2. Sentry (Error Tracking)**

**Backend:** Configured in `backend/project/settings.py`
```python
import sentry_sdk

sentry_sdk.init(
    dsn=os.getenv("SENTRY_DSN"),
    environment=os.getenv("ENVIRONMENT", "development"),
    traces_sample_rate=1.0,
)
```

**Frontend:** Configured in `frontend/src/main.tsx`
```typescript
import * as Sentry from "@sentry/react";

Sentry.init({
  dsn: import.meta.env.VITE_SENTRY_DSN,
  integrations: [
    Sentry.browserTracingIntegration(),
    Sentry.replayIntegration(),
  ],
  tracesSampleRate: 1.0,
  replaysSessionSampleRate: 0.1,
  replaysOnErrorSampleRate: 1.0,
});
```

**Features:**
- Real-time error alerts
- Stack traces with source maps
- Session replay (see what user did before error)
- Performance monitoring

**3. Codecov (Coverage Tracking)**
- Coverage badge in README
- Pull request comments with coverage diff
- Historical coverage trends

**4. Render Dashboard**
- Server logs and metrics
- Database connection pool stats
- Deploy history and rollback

**5. Netlify Dashboard**
- Deploy previews for PRs
- Build logs
- Analytics (page views, bandwidth)
- Deploy history with one-click rollback

### Rollback Procedures

**Frontend (Automatic)**

**Trigger:** Smoke test failure after production deploy

**Process:**
1. Detect smoke test failure (exit code 1)
2. Query Netlify API for previous "ready" deploy
3. Restore previous deploy via API:
   ```bash
   curl -X POST -H "Authorization: Bearer $TOKEN" \
     "https://api.netlify.com/api/v1/sites/$SITE/deploys/$PREV_ID/restore"
   ```
4. Send Slack notification (if configured)

**Manual Rollback (Netlify):**
1. Go to Netlify dashboard → Deploys
2. Find previous successful deploy
3. Click "Publish deploy" button

**Backend (Manual)**

**Via Render Dashboard:**
1. Go to Render dashboard → Your Service
2. Click "Manual Deploy" tab
3. Select previous deploy from dropdown
4. Click "Deploy"

**Via Render CLI:**
```bash
render services deploy <service-id> --commit <previous-commit-sha>
```

**Via Git Revert:**
```bash
git revert <bad-commit-sha>
git push origin main
# This triggers new deploy with reverted code
```

### Health Checks

**Backend Health Endpoint** (if implemented):
```python
# backend/project/urls.py
from django.http import JsonResponse

def health_check(request):
    return JsonResponse({
        "status": "healthy",
        "database": "connected",  # Check DB connection
        "version": "1.0.0"
    })

urlpatterns = [
    path('health/', health_check),
    # ...
]
```

**Frontend Health Check:**
- Smoke test checks for `<div id="root">` element
- Verifies React app is rendering

### Alerting

**Sentry Alerts:**
- Configure in Sentry dashboard
- Email/Slack notifications for new errors
- Alert on error rate spike (e.g., >10 errors/minute)

**GitHub Actions Notifications:**
- Automatic email on workflow failure
- Slack integration via GitHub Apps

**Uptime Monitoring** (external services):
- **UptimeRobot** - Free tier, checks every 5 minutes
- **Pingdom** - More advanced monitoring
- **Better Stack** - Full observability platform

---

## Quick Reference Commands

### Local Development

**Backend:**
```powershell
# Activate virtual environment
.backend\env\Scripts\Activate.ps1

# Install dependencies
pip install -r backend\requirements.txt

# Run migrations
python backend\manage.py migrate

# Create superuser
python backend\manage.py createsuperuser

# Run dev server
python backend\manage.py runserver

# Run tests
cd backend
pytest

# Check code quality
black --check .
isort --check-only .
flake8 .
mypy .
```

**Frontend:**
```powershell
# Install dependencies
cd frontend
npm install

# Run dev server
npm run dev

# Run tests
npm run test

# Run tests in CI mode
npm run test:ci

# Build for production
npm run build

# Preview production build
npm run preview

# Lint
npm run lint

# Format code
npm run format
```

### CI/CD Debugging

**View workflow logs:**
```bash
# Open in browser
https://github.com/<owner>/<repo>/actions

# Or use GitHub CLI
gh run list
gh run view <run-id> --log
```

**Trigger manual workflow:**
```bash
# From GitHub UI: Actions → Select workflow → Run workflow

# Or with GitHub CLI
gh workflow run backend-ci.yml
gh workflow run frontend-ci.yml
```

**Check secrets:**
```bash
gh secret list
gh secret set RENDER_DEPLOY_URL < deploy-url.txt
```

### Deployment

**Deploy backend manually:**
```bash
# Trigger Render deploy
curl -X POST $RENDER_DEPLOY_URL
```

**Deploy frontend manually:**
```bash
cd frontend
npm run build
netlify deploy --prod --dir=dist
```

**Rollback frontend:**
```bash
# List recent deploys
netlify deploys:list

# Restore specific deploy
netlify api restoreSiteDeploy --siteId=$SITE_ID --deploy_id=$DEPLOY_ID
```

---

## Continuous Improvement

### Future Enhancements

1. **Automated Performance Testing**
   - Lighthouse CI for frontend
   - Load testing with Locust/JMeter for backend

2. **Security Scanning**
   - OWASP ZAP for vulnerability scanning
   - Snyk for dependency vulnerability checks
   - Trivy for container scanning

3. **Advanced Monitoring**
   - Application Performance Monitoring (APM) with DataDog/New Relic
   - Real User Monitoring (RUM) for frontend
   - Database query performance tracking

4. **Blue-Green Deployments**
   - Zero-downtime deploys
   - Instant rollback capability

5. **Automated Changelog Generation**
   - Generate CHANGELOG.md from commit messages
   - Auto-tag releases with semantic versioning

6. **Pull Request Previews**
   - Automatic deploy preview for each PR
   - Comment on PR with preview URL

7. **Database Backup Automation**
   - Scheduled PostgreSQL backups
   - Backup before each production deploy

### Metrics to Track

- **Build Time:** Monitor and optimize slow stages
- **Test Coverage:** Maintain >80%, track trends
- **Deployment Frequency:** How often code reaches production
- **Mean Time to Recovery (MTTR):** How fast rollbacks occur
- **Change Failure Rate:** % of deploys that fail smoke test
- **Lead Time:** Time from commit to production

---

## Conclusion

This CI/CD pipeline provides:
- ✅ **Automated quality checks** - No bad code reaches production
- ✅ **Fast feedback** - Developers know within minutes if changes break
- ✅ **Safe deployments** - Smoke tests + automatic rollback
- ✅ **Multi-environment support** - Staging for testing, production for users
- ✅ **Monitoring & observability** - Sentry, Codecov, platform dashboards

The pipeline is production-ready and follows industry best practices for Django + React applications.

For questions or improvements, refer to:
- [`.github/copilot-instructions.md`](.github/copilot-instructions.md) - Project-specific patterns
- [Backend README](backend/README.md) - Backend setup details
- [Frontend README](frontend/README.md) - Frontend setup details
- [GitHub Actions Docs](https://docs.github.com/en/actions) - Workflow syntax reference

**Maintained by:** Group BSE24-1  
**Last Updated:** October 24, 2025